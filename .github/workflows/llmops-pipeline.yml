name: End-to-End LLMOps Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-scan-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: fastapi-app
      DOCKER_USER: yujieooi2000
      DOCKER_TAG: latest
      DEPLOYMENT_FILE: k8s/deployment.yaml
      SERVICE_FILE: k8s/service.yaml
      INGRESS_FILE: k8s/ingress.yaml
      CLUSTER_NAME: my-cluster   # üîπ change if your cluster name differs

    steps:
      # 1Ô∏è‚É£ Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2Ô∏è‚É£ Set up Docker
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3Ô∏è‚É£ Log in to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Free disk space (GitHub-hosted runner)
        run: |
          echo "Before cleanup:" && df -h
          docker system prune -af || true
          sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/lib/android /opt/hostedtoolcache || true
          echo "After cleanup:" && df -h


      # 4Ô∏è‚É£ Build Docker image
      - name: Build Docker image (load into local Docker)
        run: |
          docker buildx build --platform linux/amd64 \
            -t $DOCKER_USER/$IMAGE_NAME:$DOCKER_TAG \
            -f src/Dockerfile src/ \
            --load
          docker images

      # 6Ô∏è‚É£ Run Trivy security scan
      - name: Security scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_USER }}/${{ env.IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          severity: HIGH,CRITICAL
          ignore-unfixed: true
          format: table
          scanners: vuln
          skip-version-check: true
          vuln-type: os,library
          cache-dir: /tmp/trivy-cache

      # 7Ô∏è‚É£ Push image to Docker Hub
      - name: Push Docker image
        run: |
          docker tag $DOCKER_USER/$IMAGE_NAME:$DOCKER_TAG $DOCKER_USER/$IMAGE_NAME:$DOCKER_TAG
          docker push $DOCKER_USER/$IMAGE_NAME:$DOCKER_TAG

      # 8Ô∏è‚É£ Install kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      # 9Ô∏è‚É£ Install & authenticate doctl (DigitalOcean CLI)
      - name: Install doctl
        run: | 
          sudo snap install doctl --classic || true 
          doctl version

      - name: Authenticate with DigitalOcean
        env:
          DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
        run: doctl auth init -t $DIGITALOCEAN_ACCESS_TOKEN

      # üîπ Fetch live kubeconfig (recommended method)
      - name: Configure kubeconfig
        env:
          DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
        run: |
          mkdir -p $HOME/.kube
          doctl kubernetes cluster kubeconfig show $CLUSTER_NAME --expiry-seconds 600 > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          kubectl config current-context

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Install ingress-nginx via Helm
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --create-namespace --namespace ingress-nginx

      # ‚öôÔ∏è AUTO-DETECT & UPDATE INGRESS IP
      - name: Wait for ingress-nginx external IP
        id: ingress-ip
        run: |
          echo "Waiting for external IP..."
          for i in {1..20}; do
            IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ ! -z "$IP" ]; then
              echo "Ingress IP detected: $IP"
              echo "ip=$IP" >> $GITHUB_OUTPUT
              break
            fi
            echo "‚è≥ Waiting for IP... ($i/20)"
            sleep 15
          done

      # üîÑ Update service.yml (contains ingress definition)
      - name: Update service.yml with external IP
        run: |
          INGRESS_IP=${{ steps.ingress-ip.outputs.ip }}
          if [ -z "$INGRESS_IP" ]; then
            echo "‚ùå No ingress IP found. Exiting."
            exit 1
          fi
          echo "üåç Updating host in service.yml to gpt.${INGRESS_IP}.sslip.io"
          sed -i "s/host: .*/host: gpt.${INGRESS_IP}.sslip.io/" $SERVICE_FILE
          echo "‚úÖ Updated service.yml:"
          cat $SERVICE_FILE

      # üîπ Deploy to Kubernetes (disable validation to avoid openapi issues)
      - name: Deploy to Kubernetes
        env:
          DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          KUBECONFIG: ${{ env.KUBECONFIG }}
        run: |
          kubectl apply -f $DEPLOYMENT_FILE --validate=false
          kubectl apply -f $SERVICE_FILE --validate=false

      - name: Verify Ingress URL
        run: |
          echo "‚úÖ Deployment completed."
          echo "You can access your app at:"
          echo "üëâ http://gpt.${{ steps.ingress-ip.outputs.ip }}.sslip.io"
